---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by wuxin.
--- DateTime: 2019-11-14 18:12
---
---
local ck = require "resty.cookie"
local Object = require "kong.vendor.classic"
local redismod = require "resty.redis"

local HttpMethod = Object:extend()

function HttpMethod:new()

end
function HttpMethod:getScopeValue() end
function HttpMethod:build(t,conf)
    kong.log.err("in HttpMethod build...",t.scope)
    -- 请求参数
    t = self:appendRequestParam(t)
    -- IP
    t = self:appendIP(t)

    -- 请求头
    t = self:appendHeader(t)

    -- 请求cookie
    t = self:appendCookie(t)

    -- 用户信息
    t = self:appendUser(t,conf)


    return t

end

-- 将header加入表中
function HttpMethod:appendHeader(t)
    for name, value in pairs(ngx.req.get_headers()) do
        t["header_"..name] = value
    end

    self.header = ngx.req.get_headers()
    return t
end

-- 将cookie加入表中
function HttpMethod:appendCookie(t)
    local cookie, err = ck:new()
    if err then
        kong.log.err( err)
        return t
    end

    -- get all cookies
    local fields, err = cookie:get_all()
    if err then
        kong.log.err( err)
        return t
    end

    for k, v in pairs(fields) do
        t["cookie_"..k] = v
    end

    self.cookie = ngx.var.http_cookie

    return t
end

-- 将IP加入表中
function HttpMethod:appendIP(t)
    local ip = ngx.req.get_headers()["X-Forwarded-For"]
    if not ip then
        ip = ngx.req.get_headers()["remote_addr"]
    end

    t["IP"] = ip

    return t
end

local function closeConnection(conn)
    conn:set_keepalive(2 * 60 * 1000, 10) -- 单位 ms
end

-- 从redis中拿用户信息放到请求参数中
function HttpMethod:appendUser(t,conf)
    local token = ngx.var["cookie_"..conf.cookiesName]
    if not token or token == "" then
        return
    end

    -- 连接redis
    local redis = redismod:new()
    redis:set_timeouts(conf.redisTimeout, conf.redisTimeout, conf.redisTimeout)

    local ok, err = redis:connect(conf.redisHost, conf.redisPort)
    if not ok then
        kong.log.err("failed to connect redis: ", err)
        return
    end


    local res, err = redis:get(conf.tokenPrefix .. token)

    if err or not res or res == ngx.null then
        closeConnection(redis)
        return
    end

    t["user"] = res
    kong.log.err("user=",res)
    return t
end





-- get 方法对应的实现
local GetMethod = HttpMethod:extend()

function GetMethod:new()
    self.method = ngx.HTTP_GET
end

function GetMethod:getScopeValue()

     local scope = ngx.req.get_uri_args()["scope"]
     return scope
end

function GetMethod:appendRequestParam(t)
    for name, value in pairs(ngx.req.get_uri_args()) do
        t[name] = value
    end

    return t
end






-- post方法对应的实现
local PostMethod = HttpMethod:extend()

function PostMethod:new()
    self.method = ngx.HTTP_POST
    -- ngx.req.read_body()

    local uri_args = kong.request.get_query()  -- url参数
    local body_args = kong.request.get_body()  -- 表单参数
    local ptalbe = kong.table.merge(uri_args, body_args)
    self.ptalbe = ptalbe
end

function PostMethod:getScopeValue()

    return self.ptalbe["scope"]
end

function PostMethod:appendRequestParam(t)
    for name, value in pairs(self.ptalbe) do
        t[name] = value
    end
    return t
end







local httpmod = require "resty.http"
local cjson = require "cjson.safe"

local kong = kong

local ejudataauth = {}
ejudataauth.VERSION = "1.0"
ejudataauth.PRIORITY=220


function ejudataauth:access(conf)

    -- 如果其它插件设置了这个标志，则表示无需再作任何处理
    if ngx.ctx.eju_dont_do_anything then
        return
    end


    -- 从请求参数中获取scope
    local method = ngx.req.get_method()

    local httpMethod
    if method == "GET" then
        httpMethod = GetMethod()
    elseif method == "POST" then
        httpMethod = PostMethod()
    else
        return
    end

    local scope = httpMethod:getScopeValue()
    if not scope then
        kong.log.err("没有找到scope")
        return
     end

    -- 将请求参数拼装成一个json，供授权服务器决定是否返回令牌
    local paramTable = {}
    paramTable.scope = scope
    httpMethod:build(paramTable,conf)


    -- 验证自己
    local base64 = ngx.encode_base64(conf.clientId ..":" ..  conf.clientSecret)

    -- 如果授权服务器也走了该插件，则能过break跳过请求授权服务器，避免死循环
    if not paramTable["break"] then
        local authctx = ngx.encode_base64(cjson.encode(paramTable))

        local http = httpmod:new()
        http:set_timeouts(conf.authServerTimeout,conf.authServerTimeout,conf.authServerTimeout)

        kong.log.err("send request to:",conf.tokenURL)
        local res, err = http:request_uri(conf.tokenURL, {
            method = "POST",
            headers = {
                ["Content-Type"] = "application/x-www-form-urlencoded",
                ["Authorization"] = "Basic ".. base64,
                -- ["Accept"] = "application/json"
            },
            body = "&authctx=" .. authctx .. "&info=" .. scope  ,
            query = "break=1",

            keepalive_timeout = 60,
            keepalive_pool = 10
        })

        closeConnection(http)

        if  err or  not res then
            kong.log.err("request : ",conf.tokenURL ," error! or return nil ", err)
            return
        else
            kong.log.err("response from ",conf.tokenURL, " : ", res.status, res.body)
        end

        if  res.status ~= ngx.HTTP_OK  then
            kong.log.err(cjson.encode(paramTable),"无权访问数据")
            ngx.ctx.eju_dont_do_anything = true
            return kong.response.exit(ngx.HTTP_FORBIDDEN, { message = "Your Request is not allowed" })

        end


    else
        kong.log.err(cjson.encode(paramTable))
    end





end



return ejudataauth